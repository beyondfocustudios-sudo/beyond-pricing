#!/usr/bin/env npx tsx
/**
 * build-tokens.ts
 *
 * Reads design-tokens/tokens.json (or tokens.example.json as fallback)
 * and generates:
 *   1. src/styles/tokens.css  â€” CSS custom properties (:root + [data-theme="light"])
 *   2. src/lib/motion.ts      â€” Framer Motion presets
 *
 * Usage:
 *   npx tsx scripts/build-tokens.ts
 *   npm run tokens:build
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { resolve, dirname } from "path";

// â”€â”€ Paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ROOT = resolve(import.meta.dirname ?? __dirname, "..");
const TOKENS_PATH = resolve(ROOT, "design-tokens/tokens.json");
const TOKENS_EXAMPLE = resolve(ROOT, "design-tokens/tokens.example.json");
const CSS_OUT = resolve(ROOT, "src/styles/tokens.css");
const MOTION_OUT = resolve(ROOT, "src/lib/motion.ts");

// â”€â”€ Load Tokens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadTokens(): Record<string, any> {
  const path = existsSync(TOKENS_PATH) ? TOKENS_PATH : TOKENS_EXAMPLE;
  console.log(`ğŸ“¦ Loading tokens from: ${path.replace(ROOT + "/", "")}`);
  return JSON.parse(readFileSync(path, "utf-8"));
}

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resolveRef(value: string, tokens: Record<string, any>): string {
  // Resolve {group.key} references
  const match = value.match(/^\{(.+)\.(.+)\}$/);
  if (!match) return value;
  const [, group, key] = match;
  return tokens[group]?.[key]?.value ?? value;
}

function colorLine(name: string, token: { value: string }, tokens: Record<string, any>): string {
  const val = resolveRef(token.value, tokens);
  return `    --${name}: ${val};`;
}

function ensureDir(filePath: string) {
  const dir = dirname(filePath);
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
}

// â”€â”€ Generate CSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateCSS(tokens: Record<string, any>): string {
  const lines: string[] = [];
  const push = (s: string) => lines.push(s);

  push("/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  push("   AUTO-GENERATED by scripts/build-tokens.ts");
  push("   Do NOT edit manually â€” run: npm run tokens:build");
  push("   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */");
  push("");

  // â”€â”€ :root (dark default) â”€â”€
  push(":root {");

  // Brand
  push("  /* Brand */");
  for (const [k, v] of Object.entries(tokens.brand ?? {})) {
    if (v && typeof v === "object" && "value" in v) {
      push(colorLine(`brand-${k}`, v as any, tokens));
    }
  }
  push("");

  // Coal
  push("  /* Coal */");
  for (const [k, v] of Object.entries(tokens.coal ?? {})) {
    if (v && typeof v === "object" && "value" in v) {
      push(colorLine(`coal-${k}`, v as any, tokens));
    }
  }
  push("");

  // Semantic dark
  push("  /* Semantic â€” Dark */");
  const darkSemantic = tokens.semantic?.dark ?? {};
  for (const [k, v] of Object.entries(darkSemantic)) {
    if (v && typeof v === "object" && "value" in v) {
      push(colorLine(k, v as any, tokens));
    }
  }
  push("");

  // Status
  push("  /* Status */");
  for (const [k, v] of Object.entries(tokens.status ?? {})) {
    if (v && typeof v === "object" && "value" in v) {
      push(colorLine(k, v as any, tokens));
    }
  }
  push("");

  // Glass dark
  push("  /* Glass â€” Dark */");
  const darkGlass = tokens.glass?.dark ?? {};
  for (const [k, v] of Object.entries(darkGlass)) {
    if (v && typeof v === "object" && "value" in v) {
      const val = resolveRef((v as any).value, tokens);
      push(`    --glass-${k}: ${val};`);
    }
  }
  push("");

  // Radii
  push("  /* Radii */");
  for (const [k, v] of Object.entries(tokens.radii ?? {})) {
    if (v && typeof v === "object" && "value" in v) {
      push(`    --r-${k}: ${(v as any).value};`);
    }
  }
  push("");

  // Shadows dark
  push("  /* Shadows â€” Dark */");
  const darkShadows = tokens.shadows?.dark ?? {};
  for (const [k, v] of Object.entries(darkShadows)) {
    if (v && typeof v === "object" && "value" in v) {
      push(`    --shadow-${k}: ${(v as any).value};`);
    }
  }
  push("");

  // Pastels dark
  push("  /* Pastels â€” Dark */");
  const darkPastels = tokens.pastel?.dark ?? {};
  for (const [k, v] of Object.entries(darkPastels)) {
    if (v && typeof v === "object" && "value" in v) {
      push(`    --pastel-${k}: ${(v as any).value};`);
    }
  }

  push("}");
  push("");

  // â”€â”€ [data-theme="light"] â”€â”€
  push('[data-theme="light"] {');

  // Semantic light
  push("  /* Semantic â€” Light */");
  const lightSemantic = tokens.semantic?.light ?? {};
  for (const [k, v] of Object.entries(lightSemantic)) {
    if (v && typeof v === "object" && "value" in v) {
      push(colorLine(k, v as any, tokens));
    }
  }
  push("");

  // Glass light
  push("  /* Glass â€” Light */");
  const lightGlass = tokens.glass?.light ?? {};
  for (const [k, v] of Object.entries(lightGlass)) {
    if (v && typeof v === "object" && "value" in v) {
      const val = resolveRef((v as any).value, tokens);
      push(`    --glass-${k}: ${val};`);
    }
  }
  push("");

  // Shadows light
  push("  /* Shadows â€” Light */");
  const lightShadows = tokens.shadows?.light ?? {};
  for (const [k, v] of Object.entries(lightShadows)) {
    if (v && typeof v === "object" && "value" in v) {
      push(`    --shadow-${k}: ${(v as any).value};`);
    }
  }
  push("");

  // Pastels light
  push("  /* Pastels â€” Light */");
  const lightPastels = tokens.pastel?.light ?? {};
  for (const [k, v] of Object.entries(lightPastels)) {
    if (v && typeof v === "object" && "value" in v) {
      push(`    --pastel-${k}: ${(v as any).value};`);
    }
  }

  push("}");

  return lines.join("\n") + "\n";
}

// â”€â”€ Generate Motion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateMotion(tokens: Record<string, any>): string {
  const motion = tokens.motion ?? {};
  const easeOut = motion.easeOut?.value ?? [0.22, 1, 0.36, 1];
  const easeInOut = motion.easeInOut?.value ?? [0.4, 0, 0.2, 1];
  const springs = motion.spring ?? {};
  const durations = motion.durations ?? {};

  const springEntries = Object.entries(springs)
    .filter(([, v]) => Boolean(v) && typeof v === "object" && "stiffness" in (v as any))
    .map(([k, v]: [string, any]) =>
      `  ${k}: { type: "spring", stiffness: ${v.stiffness}, damping: ${v.damping}, mass: ${v.mass} } satisfies Transition,`
    )
    .join("\n");

  const durationEntries = Object.entries(durations)
    .filter(([, v]) => Boolean(v) && typeof v === "object" && "value" in (v as any))
    .map(([k, v]: [string, any]) =>
      `  ${k}: ${v.value},`
    )
    .join("\n");

  return `/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AUTO-GENERATED by scripts/build-tokens.ts
   Do NOT edit manually â€” run: npm run tokens:build
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
"use client";

import { useEffect, useState } from "react";
import { useReducedMotion, type MotionProps, type Transition, type Variants } from "framer-motion";

const easeOutBase44 = [${easeOut.join(", ")}] as const;
const easeInOutBase44 = [${easeInOut.join(", ")}] as const;

export const ease = {
  fade: easeOutBase44,
  inOut: easeInOutBase44,
} as const;

export const spring = {
${springEntries}
};

export const durations = {
${durationEntries}
};

export const transitions = {
  page: { duration: durations.fade, ease: ease.fade } satisfies Transition,
  fadeSlide: { duration: durations.fade, ease: ease.fade } satisfies Transition,
  micro: spring.fast,
  ui: spring.ui,
  soft: spring.soft,
  smooth: { duration: durations.fade, ease: ease.fade } satisfies Transition,
  inOut: { duration: durations.fadeSlow, ease: ease.inOut } satisfies Transition,
};

export const variants = {
  page: {
    initial: { opacity: 0, y: 8 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -8 },
  } satisfies Variants,
  containerStagger: {
    initial: {},
    animate: {
      transition: {
        staggerChildren: 0.06,
        delayChildren: 0.06,
      },
    },
    exit: {
      transition: {
        staggerChildren: 0.03,
        staggerDirection: -1,
      },
    },
  } satisfies Variants,
  itemEnter: {
    initial: { opacity: 0, y: 10, scale: 0.995 },
    animate: { opacity: 1, y: 0, scale: 1, transition: transitions.fadeSlide },
    exit: { opacity: 0, y: -8, scale: 0.99, transition: transitions.fadeSlide },
  } satisfies Variants,
  cardEnter: {
    initial: { opacity: 0, y: 14, scale: 0.98 },
    animate: { opacity: 1, y: 0, scale: 1, transition: transitions.soft },
    exit: { opacity: 0, y: -10, scale: 0.985, transition: transitions.fadeSlide },
  } satisfies Variants,
  modalEnter: {
    initial: { opacity: 0, scale: 0.98, y: 8 },
    animate: { opacity: 1, scale: 1, y: 0, transition: transitions.soft },
    exit: { opacity: 0, scale: 0.985, y: 6, transition: transitions.fadeSlide },
  } satisfies Variants,
  tab: {
    initial: { opacity: 0, x: 10 },
    animate: { opacity: 1, x: 0, transition: transitions.fadeSlide },
    exit: { opacity: 0, x: -10, transition: transitions.fadeSlide },
  } satisfies Variants,
  listItem: {
    initial: { opacity: 0, height: 0, y: 8, scale: 0.995 },
    animate: { opacity: 1, height: "auto", y: 0, scale: 1, transition: transitions.soft },
    exit: { opacity: 0, height: 0, y: -8, scale: 0.99, transition: transitions.fadeSlide },
  } satisfies Variants,
  fadeIn: {
    initial: { opacity: 0 },
    animate: { opacity: 1, transition: transitions.fadeSlide },
    exit: { opacity: 0, transition: transitions.fadeSlide },
  } satisfies Variants,
};

export function useMotionEnabled() {
  const reduceMotion = useReducedMotion();
  return !reduceMotion;
}

export function motionSafe<T>(enabled: boolean, value: T): T | undefined {
  return enabled ? value : undefined;
}

export function reducedMotionSafe<T>(reduced: boolean, value: T): T | undefined {
  return reduced ? undefined : value;
}

export function useDesktopHoverMotion() {
  const enabled = useMotionEnabled();
  const [canHover, setCanHover] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") return;
    const mq = window.matchMedia("(min-width: 1024px) and (hover: hover) and (pointer: fine)");
    const onChange = () => setCanHover(mq.matches);
    onChange();
    mq.addEventListener("change", onChange);
    return () => mq.removeEventListener("change", onChange);
  }, []);

  return enabled && canHover;
}

export function buttonMotionProps(opts: {
  enabled: boolean;
  hoverY?: number;
  tapScale?: number;
}): Pick<MotionProps, "whileHover" | "whileTap" | "transition"> {
  if (!opts.enabled) return {};
  return {
    whileHover: { y: opts.hoverY ?? -1.5, scale: 1.01 },
    whileTap: { scale: opts.tapScale ?? 0.98 },
    transition: transitions.ui,
  };
}

export function cardHoverProps(enabled: boolean): Pick<MotionProps, "whileHover" | "transition"> {
  if (!enabled) return {};
  return {
    whileHover: { y: -4, scale: 1.004 },
    transition: transitions.ui,
  };
}
`;
}

// â”€â”€ Validate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function validateTokens(tokens: Record<string, any>): string[] {
  const errors: string[] = [];
  const required = ["brand", "coal", "semantic", "status", "radii", "shadows", "motion"];
  for (const key of required) {
    if (!tokens[key]) errors.push(`Missing required group: "${key}"`);
  }
  if (tokens.semantic && (!tokens.semantic.dark || !tokens.semantic.light)) {
    errors.push('semantic must have "dark" and "light" sub-groups');
  }
  if (tokens.motion) {
    if (!tokens.motion.easeOut) errors.push("motion.easeOut is required");
    if (!tokens.motion.spring) errors.push("motion.spring is required");
    if (!tokens.motion.durations) errors.push("motion.durations is required");
  }
  return errors;
}

// â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function main() {
  const isValidateOnly = process.argv.includes("--validate");
  const tokens = loadTokens();

  // Validate
  const errors = validateTokens(tokens);
  if (errors.length > 0) {
    console.error("âŒ Token validation failed:");
    errors.forEach((e) => console.error(`   â€¢ ${e}`));
    process.exit(1);
  }
  console.log("âœ… Token structure valid");

  if (isValidateOnly) {
    console.log("ğŸ” Validate-only mode â€” no files written");
    process.exit(0);
  }

  // Generate CSS
  ensureDir(CSS_OUT);
  const css = generateCSS(tokens);
  writeFileSync(CSS_OUT, css, "utf-8");
  console.log(`âœ… Generated: ${CSS_OUT.replace(ROOT + "/", "")}`);

  // Generate Motion
  ensureDir(MOTION_OUT);
  const motion = generateMotion(tokens);
  writeFileSync(MOTION_OUT, motion, "utf-8");
  console.log(`âœ… Generated: ${MOTION_OUT.replace(ROOT + "/", "")}`);

  console.log("\nğŸ¨ Token build complete!");
}

main();
